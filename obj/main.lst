C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE main
OBJECT MODULE PLACED IN .\obj\main.obj
COMPILER INVOKED BY: D:\KeilMDK\C251\BIN\C251.EXE User\main.c XSMALL INTR2 OPTIMIZE(0,SPEED) BROWSE INCDIR(.\User;.\Hard
                    -ware\CalcDoseRate;.\Hardware\Cmd;.\Hardware\Flash;.\Hardware\IIC;.\Hardware\Mcp4725;.\Hardware\Sensor;.\Hardware\System;
                    -.\Hardware\Uart;.\User;.\Hardware\BatVoltage;.\Hardware\DoseRate;.\Hardware\CalcCps;.\Hardware\CRC;.\Hardware\Queue) PRI
                    -NT(.\obj\main.lst) OBJECT(.\obj\main.obj) 

stmt  level    source

    1          #include "Sensor.h"
    2          #include "mcp4725.h"
    3          #include "system.h"
    4          #include "main.h"
    5          #include "CMD.h"
    6          #include "uart.h"
    7          #include "i2c.h"
    8          #include "flash.h"
    9          #include "CalcDoseRate.h"
   10          #include "DoseRate.h"
   11          
   12          LP_SYSTEM_STTAE SysRunState={0};
   13          extern void Adc_Init();
   14          extern uint16_t DeviceGetBatVal(void);
   15          extern void DeviceGetBatAlarm(STU_BATTERY *bat);
   16          extern STU_BATTERY s_Bat;
   17          
   18          //unsigned int ADC16Result = 0; 
   19          
   20          //========================================================================
   21          // 函数名称: void InitParam()
   22          // 函数功能: 初始化各个参数
   23          // 入口参数: @无
   24          // 函数返回: 无
   25          // 当前版本: VER1.0
   26          // 修改日期: 2023.5.5
   27          // 当前作者:
   28          // 其他备注: 
   29          //========================================================================
   30          
   31          void InitParam()
   32          {
   33   1              memset((void*)&SysRunState.stParam,0,sizeof(LP_PARAM));
   34   1              SysRunState.stParam.SensorType = SENSOR_LONGPOLE;          //探头类型
   35   1              SysRunState.stParam.s_SysParam.Hv = 800;                   //高压值
   36   1              SysRunState.stParam.s_SysParam.Z1 = 2500-200;              //甄别器阈值1
   37   1              SysRunState.stParam.s_SysParam.Ct = 1000;                  //计数时间
   38   1              SysRunState.stParam.s_SysParam.Hd = 3;                     //高压误差
   39   1              SysRunState.stParam.s_SysParam.Z2 = 1100;                  //甄别器阈值2
   40   1              SysRunState.stParam.s_SysParam.Hn = 0x5a;
   41   1      
   42   1              SysRunState.stParam.s_SysParam.DiYaCanshuA = 1.06581410364015E-14;//0.63;         //低量程通道校准因子
   43   1              SysRunState.stParam.s_SysParam.DiYaCanshuB = 0.291478787484166;      //0.00019;   //低量程通道校准因子
   44   1              SysRunState.stParam.s_SysParam.DiYaCanshuC = 0.0108551044292504;     //0.83;      //1;低量程通道校准因子
   45   1              SysRunState.stParam.s_SysParam.GaoYaCanshuA = 36242.9291771224;      //33.6;        //高量程通道校准因子
   46   1              SysRunState.stParam.s_SysParam.GaoYaCanshuB = 13.9188068943568;      //0.000023;    //高量程通道校准因子
   47   1              SysRunState.stParam.s_SysParam.GaoYaCanshuC = 0.000875735882434164;//0.83;        //高量程通道校准因子
   48   1              
   49   1              SysRunState.stParam.s_Alarm.DosePreAlarm = 300;            //300uSv
   50   1              SysRunState.stParam.s_Alarm.DoseAlarm = 400;               //400uSv
   51   1              SysRunState.stParam.s_Alarm.DoseRatePreAlarm = 300;        //300uSv/h
   52   1              SysRunState.stParam.s_Alarm.DoseRateAlarm = 400;           //400uSv/h
   53   1      
   54   1              WritePara();
   55   1      }
   56          
C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 2   

   57          void DevInit(void)
   58          {
   59   1          BLUE_PWOFF();
   60   1          GDoseSeg = LOW_SEG;
   61   1              BLUE_CFG_MODE();
   62   1              BLUE_WAKEUP();
   63   1      }
   64          void sysSleep(void)
   65          {
   66   1              SysRunState.isSleep = 1;
   67   1      }
   68          
   69          void DevSleep(void)
   70          {
   71   1              BLUE_CFG_MODE();
   72   1              delay_ms(2500);
   73   1              uartble_send("AT+CLEARADDR\r\n",14);    //清除远端蓝牙地址
   74   1              delay_ms(500);
   75   1              BLUE_WORK_MODE();
   76   1              BLUE_SLEEP();
   77   1              sysSleep();
   78   1              SensorMeasureBegin();//开始测量 
   79   1      }
   80          
   81          void Error()
   82          {
   83   1          while(1)
   84   1          {
   85   2              //Light_M(1);
   86   2              delay_ms(50);
   87   2              //Light_M(0);
   88   2              delay_ms(50);
   89   2          }
   90   1      }
   91          
   92          void BtInit()
   93          {
   94   1          BLUE_WORK_MODE();
   95   1          BLUE_SLEEP();
   96   1          BLUE_PWOFF();
   97   1          delay_ms(500);
   98   1          
   99   1          BLUE_PWON();
  100   1          BLUE_WAKEUP();
  101   1          BLUE_CFG_MODE(); 
  102   1      
  103   1          
  104   1              uartble_send("AT+ROLE=0\r\n",11);//从模式
  105   1              delay_ms(500);
  106   1              uartble_send("AT+LOWPOWER=1\r\n",15);//允许低功耗
  107   1              delay_ms(500);
  108   1              uartble_send("AT+TXPOWER=7\r\n",14);//发射功率0~7
  109   1              delay_ms(500);
  110   1          
  111   1              uartble_send("AT+CLEARADDR\r\n",14);//清除远端蓝牙地址
  112   1              delay_ms(500);
  113   1              uartble_send("AT+AUTH=1\r\n",11);//设置鉴权
  114   1              delay_ms(500);
  115   1              uartble_send("AT+BIND=1\r\n",11);//设置绑定地址
  116   1              delay_ms(500);
  117   1      //    uartble_send("AT+LADDR?\r\n",11);
  118   1      //    delay_ms(500);
  119   1      //    uartble_send("AT+RADDR?\r\n",11);
  120   1      //    delay_ms(500);
  121   1              /*uartble_send("AT+RADDR?\r\n",11);//
  122   1              delay_ms(500);
C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 3   

  123   1              uartble_send("AT+BLECONNPARAM?\r\n",18);
  124   1              delay_ms(1000);
  125   1              uartble_send("AT+DFU\r\n",8);
  126   1              delay_ms(1000);*/
  127   1      
  128   1          
  129   1          BLUE_WORK_MODE();
  130   1      }
  131          
  132          
  133          //========================================================================
  134          // 函数名称: void delay_ms(WORD ms) _11MHz 
  135          // 函数功能: 毫秒延时函数
  136          // 入口参数: @WORD ms：延时多少毫秒
  137          // 函数返回: 无
  138          // 当前版本: VER1.0
  139          // 修改日期: 2023.5.5
  140          // 当前作者:
  141          // 其他备注: 
  142          //========================================================================
  143          //void delay_ms(WORD ms)              
  144          //{
  145          //    WORD t = 1000;
  146          //    while(ms--)
  147          //    {
  148          //        for (t=0;t<1000;t++) ;
  149          //    }
  150          //}
  151          
  152          
  153          void delay_ms(WORD ms)  //@6.000MHz
  154          {
  155   1              DWORD i;
  156   1          while(ms--)
  157   1          {
  158   2              _nop_();
  159   2              _nop_();
  160   2              _nop_();
  161   2              i = 1498UL;
  162   2              while (i) i--;
  163   2          }
  164   1      }
  165          
  166          
  167          void delay_us(BYTE us)
  168          {
  169   1          while(us--)
  170   1          {
  171   2              ;
  172   2          }
  173   1      }
  174          
  175          //========================================================================
  176          // 函数名称: void IoInit()
  177          // 函数功能: 单片机I/O口初始化
  178          // 入口参数: @无
  179          // 函数返回: 无
  180          // 当前版本: VER1.0
  181          // 修改日期: 2023.5.5
  182          // 当前作者:
  183          // 其他备注: 
  184          //========================================================================
  185          void IoInit()
  186          {
  187   1          EAXFR = 1;
  188   1          WTST = 0;                       //设置程序指令延时参数，赋值为0可将CPU执行指令的速度设置为最快
C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 4   

  189   1      
  190   1          P0M1 = 0xFC;   P0M0 = 0x00;     //设置为准双向口           P0M1 = 0x50
  191   1          P1M1 = 0xFB;   P1M0 = 0x00;     //设置为准双向口           P1M1 = 0x02    
  192   1          P2M1 = 0xCF;   P2M0 = 0x00;     //设置为准双向口
  193   1          P3M1 = 0x0C;   P3M0 = 0x00;     //P3.3设置为推挽输出
  194   1          P4M1 = 0xB1;   P4M0 |=(1<<1)|(1<<2)|(1<<3)|(1<<6);     //设置为准双向口
  195   1          P5M1 = 0x0B;   P5M0 |=(1<<2);     //设置为准双向口
  196   1      }
  197          
  198          //========================================================================
  199          // 函数名称: void TimerTask()
  200          // 函数功能: 定时任务，通过定时器0定时10ms来设置相关任务
  201          // 入口参数: @无
  202          // 函数返回: 无
  203          // 当前版本: VER1.0
  204          // 修改日期: 2023.5.5
  205          // 当前作者:
  206          // 其他备注: 
  207          //========================================================================
  208          void TimerTask()
  209          {
  210   1          u16 delta = 0;
  211   1          static u16 Time1s = 0;
  212   1          if(Timer0Cnt)
  213   1          {
  214   2              delta = Timer0Cnt * 10;
  215   2              Timer0Cnt = 0;
  216   2              if(RX1_Cnt>0)
  217   2              {
  218   3                  Rx1_Timer += delta;
  219   3              }
  220   2              if(RX3_Cnt>0)
  221   2              {
  222   3                  Rx3_Timer += delta;
  223   3              }
  224   2              Time1s += delta;
  225   2              if(Time1s >= 1000)                      //100*10=1000ms
  226   2              {         
  227   3                  Time1s = 0;
  228   3                  SysRunState.isCanReadSensor = 1;
  229   3              }
  230   2              Light_Run(delta);
  231   2              
  232   2          }
  233   1      }
  234          
  235          //========================================================================
  236          // 函数名称: void BleHnd()
  237          // 函数功能: 通过BLE与上位机握手
  238          // 入口参数: @无
  239          // 函数返回: 无
  240          // 当前版本: VER1.0
  241          // 修改日期: 2023.5.5
  242          // 当前作者:
  243          // 其他备注: 
  244          //========================================================================
  245          void BleHnd()
  246          {
  247   1          if(revFlag)
  248   1          {
  249   2              if(Rx1_Timer > 20)                  //串口超时20ms
  250   2              {
  251   3                  Rx1_Timer = 0;
  252   3                  DataPro(RX1_Buffer,RX1_Cnt);
  253   3                  //uart485_send(RX1_Buffer,RX1_Cnt);
  254   3                  ClearBleBuf();  
C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 5   

  255   3                  revFlag = 0;
  256   3              }
  257   2          }
  258   1          else
  259   1          {
  260   2              if(SysRunState.NoUartTime > POWER_OFF_TIME)
  261   2              {
  262   3                  DevSleep();
  263   3              }
  264   2              else
  265   2              {
  266   3                  sysSleep();
  267   3              }
  268   2          }
  269   1      }
  270          
  271          void Light_Run(u16 dt)
  272          {
  273   1          static u16 counter = 0;
  274   1          u16 compare = 5000;
  275   1          counter += dt;
  276   1          if(counter > compare)
  277   1          {
  278   2              counter = 0;
  279   2              Light_M(0);
  280   2          }
  281   1          else if(counter >= (compare - 100))
  282   1          {      
  283   2              Light_M(1);
  284   2          }
  285   1      }
  286          
  287          int main(void)
  288          {    
  289   1          SysInit();
  290   1          IoInit();
  291   1          
  292   1          Light_M(1);
  293   1          Adc_Init();
  294   1              DevInit();
  295   1          delay_ms(200);
  296   1          
  297   1          Uart1_Init();
  298   1          ClearBleBuf();
  299   1          //Uart3_Init();
  300   1          //ClearRs485Buf();
  301   1               
  302   1          delay_ms(500);
  303   1          
  304   1          Timer0_Init();
  305   1          
  306   1              Timer3_Init();
  307   1              Timer4_Init();
  308   1          
  309   1          delay_ms(500);
  310   1          
  311   1              GetPara(&SysRunState.stParam);
  312   1          delay_ms(1000);
  313   1          
  314   1          SensorInit();
  315   1          
  316   1          Light_M(0);
  317   1        
  318   1              EA = 1;
  319   1          //ADC_CONTR &= ~(1<<8);     //不使能 ADC 模块
  320   1      //    IDL = 1;
C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 6   

  321   1      //    _nop_();
  322   1      //    _nop_();
  323   1      //    _nop_();
  324   1      //    _nop_();
  325   1              //开机先检测一次电池电量
  326   1          DeviceGetBatVal();
  327   1      
  328   1          BtInit();
  329   1          DeviceGetBatVal();
  330   1          revFlag = 0;
  331   1              BLUE_SLEEP();
  332   1              DeviceGetBatAlarm(&s_Bat);//开机先检测一次电池电量
  333   1      
  334   1              SensorMeasureBegin();//开始测量 
  335   1              InitArr();
  336   1          MCP4725_OutVol(MCP4725_S1_ADDR,2500-(WORD)SysRunState.stParam.s_SysParam.Z1);
  337   1              delay_ms(100);
  338   1          while(1)
  339   1          {   
  340   2              TimerTask();           
  341   2              if(SysRunState.isCanReadSensor == 1)
  342   2              {
  343   3                 
  344   3                  CaptureSensorPluseCounter(); //捕获当前测量结果
  345   3                  SensorMeasureBegin();         //开始测量 
  346   3                  SysRunState.isCanReadSensor = 0;
  347   3              }
  348   2      
  349   2              if((SysRunState.NoUartTime >= 90*100)&&(SysRunState.NoUartTime < 93*100))
  350   2              {
  351   3                  //长时间无通信数据尝试复位蓝牙模块
  352   3                  BtInit();
  353   3                  RX1_Cnt = 0;
  354   3                  revFlag = 0;
  355   3                  SensorMeasureBegin();//开始测量 
  356   3                  SysRunState.NoUartTime = 93*100;
  357   3              }
  358   2              BleHnd();
  359   2              //Uart3Hnd();
  360   2              
  361   2          }
  362   1      }
  363          
  364          
  365          
  366          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      1038     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       244     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       325     ------
End of Module Information.

C251 COMPILER V5.60.0,  main                                                               18/01/24  11:12:20  PAGE 7   


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
